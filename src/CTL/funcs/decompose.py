import numpy as np 
import CTL.funcs.funcs as funcs

def firstZeroIndex(s, eps = 1e-10):
    """
    Find the first index that is non zero in the (singular value) array.

    Parameters
    ----------
    s : 1-D ndarray of float

    eps : float, default 1e-10
        The threshold of deciding a value is zero.

    Returns
    -------
    int
        If s has zero-elements: return the first index of zero element.
        Otherwise, return len(s).
    """
    for i in range(len(s)):
        if funcs.floatEqual(s[i], 0.0, eps = eps):
            return i
    return len(s)

def SVDDecomposition(a, chi, np = np):
    """
    SVD decomposition of a given matrix, keep at most chi singular values. Singular values are divided into square roots and go to each side.

    Parameters
    ----------
    a : 2-D ndarray of float
        The matrix to decompose, shape (n, m).
    chi : int
        The maximum number of non-zero singular values to be kept.
    np : object, default numpy
		The numpy-like library for numeric functions.

    Returns
    uRes : 2-D ndarray of float
        Left part of the decomposition, shape (n, k), where k is generated by n, m, k, and the number of non-zero singular values.
    vRes : 2-D ndarray of float
        Right part of the decomposition, shape (m, k). a approximately equal to uRes @ vRes.T.
    error : float
        The loss of truncating singular values: sum(square of truncated values) / sum(square of all values).
    """

    u, s, vh = np.linalg.svd(a)
    
    sLen = len(s)
    if (chi >= sLen):
        error = 0.0
        chi = sLen
    else:
        error = np.sqrt(np.sum(s[chi:] ** 2) / np.sum(s ** 2))

    # print('old chi = {}'.format(chi))
    chi = min(chi, firstZeroIndex(s))
    # print('new chi = {}'.format(chi))
    # print('s = {}'.format(s))

    # print('error = {}'.format(error))

    u = u[:, :chi]
    s = s[:chi]
    vh = vh[:chi]

    sqrtSMat = np.diag(np.sqrt(s))

    uRes = u @ sqrtSMat
    vRes = funcs.transposeConjugate(sqrtSMat @ vh)
    return uRes, vRes, error

def SVDDecompositionWithSingularValues(a, chi, np = np):
    """
    SVD decomposition of a given matrix, keep at most chi singular values. Singular values are divided into square roots and go to each side.

    Parameters
    ----------
    a : 2-D ndarray of float
        The matrix to decompose, shape (n, m).
    chi : int
        The maximum number of non-zero singular values to be kept.
    np : object, default numpy
		The numpy-like library for numeric functions.

    Returns
    uRes : 2-D ndarray of float
        Left part of the decomposition, shape (n, k), where k is generated by n, m, k, and the number of non-zero singular values.
    s : 1-D ndarray of float
        Singular values.
    vRes : 2-D ndarray of float
        Right part of the decomposition, shape (m, k). a approximately equal to uRes @ np.diag(s) @ vRes.T.
    error : float
        The loss of truncating singular values: sum(square of truncated values) / sum(square of all values).
    """

    u, s, vh = np.linalg.svd(a)
    
    sLen = len(s)
    if (chi >= sLen):
        error = 0.0
        chi = sLen
    else:
        error = np.sqrt(np.sum(s[chi:] ** 2) / np.sum(s ** 2))

    chi = min(chi, firstZeroIndex(s))

    # print('error = {}'.format(error))

    uRes = u[:, :chi]
    s = s[:chi]
    vRes = funcs.transposeConjugate(vh[:chi])

    return uRes, s, vRes, error



