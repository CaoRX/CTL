import numpy as np 
import CTL.funcs.funcs as funcs

def SVDDecomposition(a, chi, np = np):
    """
    SVD decomposition of a given matrix, keep at most chi singular values. Singular values are divided into square roots and go to each side.

    Parameters
    ----------
    a : 2-D ndarray of float
        The matrix to decompose, shape (n, m).
    chi : int
        The maximum number of non-zero singular values to be kept.
    np : object, default numpy
		The numpy-like library for numeric functions.

    Returns
    uRes : 2-D ndarray of float
        Left part of the decomposition, shape (n, k), where k is generated by n, m, k, and the number of non-zero singular values.
    vRes : 2-D ndarray of float
        Right part of the decomposition, shape (k, m). a approximately equal to uRes @ vRes.
    error : float
        The loss of truncating singular values: sum(square of truncated values) / sum(square of all values).
    """

    u, s, vh = np.linalg.svd(a)
    
    sLen = len(s)
    if (chi >= sLen):
        error = 0.0
        chi = sLen
    else:
        error = np.sqrt(np.sum(s[chi:] ** 2) / np.sum(s ** 2))

    # print('error = {}'.format(error))

    u = u[:, :chi]
    s = s[:chi]
    vh = vh[:chi]

    sqrtSMat = np.diag(np.sqrt(s))

    uRes = u @ sqrtSMat
    vRes = funcs.transposeConjugate(sqrtSMat @ vh)
    return uRes, vRes, error



